<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>
<body>
  <a href="./01-What-is-Function.html">01-What-is-Function</a>
  <a href="./02-IIFE.html">02-IIFE</a>
  <a href="./03-closure.html">03-closure</a>
  <a href="./04-new-operator.html">04-new-operator</a>
  <a href="./05-prototype.html">05-prototype</a>
  <a href="./06-Object-create.html">06-Object-create</a>
  <a href="./07-Prototype_constructor.html">07-Prototype_constructor</a>
  <a href="./08-class.html">08-class</a>

  <h1>Class</h1>
  <h3>參考 : <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Classes">MDN : Classes</a></h3>

  <ul>
    <li>狗的印象就是一個 class, 這個印象沒有辦法直接去運用它, 它只是一個想法</li>
    <li>透過 new 的方法, 可以將狗給實體化出來, 稱為 instance</li>
    <li>實體化的狗可以定義有甚麼樣的特徵, 色彩, 體型, 實體化的狗才能真的吠叫</li>
    <li>實體化的狗是從狗這個思想所延伸出來, 稱為繼承</li>
    <li>繼承的概念就是一個實體, 可以取用另外一個物件的屬性 & 方法</li>
    <li>屬性: 色彩 & 大小, 方法: 吠叫</li>
  </ul>
  <img src="./Object-Create.png" alt="" style="width: 800px;">
  <img src="./class-Dog.png" alt="" style="width:500px">
  <img src="./Object-oriented-Programming OOP.png" style="width:500px">
</body>
</html>

<script>
  class Animal {
    constructor(family) {
      this.kingdom = '動物界';
      this.family = family || '人科';
    }
    
    move() {  // 未傳入name, 為 undefined
      console.log(`${this.name} 移動`);
    }
  }

  const newAnimal = new Animal('新物種');
  // console.log("newAnimal:", newAnimal);

  
  // extends 繼承結構, 用來建立擴展子類別
  class Dog extends Animal {

    // constructor() {} // 如果不指定建構子，就會使用預設的建構子
    constructor(name, color, size) {  // 一個 class 只能有一個稱為 constructor 的特殊物件
      super('狗科');  // super() 將資料傳到上層
      // 用來提供一個類別呼叫其父類別的函數
      // 注意 : 若在子類別中有建構子(constructor)，要使用 this 前則必須先呼叫 super()函式，不這樣的話會發生錯誤。

      this.name = name;
      this.color = color;
      this.size = size;
    }
    
    bark() {
      console.log(`${this.name} 吼叫`);
    }
    

    // 靜態方法 & 變數
    // 靜態方法(不能調用 this)
    static add(a, b){
      // console.log("this:", this);
      return a + b;
    }
    static className = '靜態變數 className';
  }

  const Bibi = new Dog('小比', '棕色', '小');
  // console.log("Bibi:", Bibi);
  // Bibi.bark();
  // Bibi.move();

  const Pupu = new Dog('噗噗', '黑色', '大');
  // console.log("Pupu:", Pupu);
  

  // console.log("Bibi.add(1, 2):", Bibi.add(1, 2));  // 無法呼叫方法
  // console.log("Bibi.className:", Bibi.className);

  // console.log("Dog.add(1,2):", Dog.add(1, 2));  // 使用建構函式直接呼叫方法
  // console.log("Dog.className:", Dog.className);



  class Cat extends Animal{
    constructor(name, color, size){
      super('貓科');
      this.name = name;
      this.color = color;
      this.size = size;
    }

    moew(){
      console.log(`${this.name} 喵喵叫`);
    }
  }

  const Mimi = new Cat('小米', '白色', '小');
  // console.log("Mimi:", Mimi);
  // Mimi.moew();
  // Mimi.bark();
</script>